name: CI/CD Deployment to Production Cluster

permissions:
  id-token: write
  contents: read

on:
  push:
    branches:
      - develop
      - release

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy-dev:
    if: github.ref == 'refs/heads/develop'  
    env:
      FULL_DOMAIN: 'dev.dstranslator.cloud'

    name: Deploying to Dev
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set_tag.outputs.IMAGE_TAG }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials for Dev
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ SECRETS.AWS_ACCOUNT_ID }}:role/dst-dev-github-deployment-role
          aws-region: ${{ SECRETS.AWS_REGION }}

      - name: Update kubeconfig for Dev
        run: aws eks update-kubeconfig --region ${{ SECRETS.AWS_REGION }} --name dst-dev-cluster

      - name: Set up Helm
        uses: azure/setup-helm@v4.3.0

      - name: Helm Lint
        run: helm lint ./helm/ds-translator

      - name: Render Templates (Helm Template)
        run: helm template dev-ds-translator ./helm/ds-translator --namespace dev --values ./helm/ds-translator/values-dev.yaml

      - name: Dry-Run Install
        run: |
          helm upgrade --install dev-ds-translator ./helm/ds-translator \
            --namespace dev \
            --create-namespace \
            --values ./helm/ds-translator/values-dev.yaml \
            --dry-run


      # - name: Determine Image Tag
      #   id: set_tag
      #   run: echo "IMAGE_TAG=${GITHUB_SHA}" >> $GITHUB_ENV

      # installed in terraform with module
      # - name: Install AWS Observability in Dev
      #   run: |      
      #     helm repo add aws-observability https://aws-observability.github.io/helm-charts
      #     helm repo update aws-observability
      #     helm install --wait --create-namespace \
      #       --namespace amazon-cloudwatch \ 
      #       amazon-cloudwatch aws-observability/amazon-cloudwatch-observability \ 
      #       --set clusterName=dst-dev-cluster \
      #       --set region=${{ SECRETS.AWS_REGION }}

      # - name: Install NVIDIA device plugin
      #   run: |
      #     kubectl apply -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/v1.12/nvidia-device-plugin.yml
      #     kubectl create -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/v0.9.0/nvidia-device-plugin.yml



      - name: Install EBS CSI Driver
        run: |
          helm repo add aws-mountpoint-ebs-csi-driver public.ecr.aws/ebs-csi-driver/aws-ebs-csi-driver:v1.40.0
          helm repo update
          helm upgrade --install aws-mountpoint-ebs-csi-driver \
            --namespace kube-system \
            aws-mountpoint-ebs-csi-driver/aws-mountpoint-ebs-csi-driver

            kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=aws-mountpoint-ebs-csi-driver -n kube-system --timeout=120s
            if [ $? -eq 0 ]; then
              echo "aws-mountpoint-ebs-csi-driver pods are running"
            else
              echo "aws-mountpoint-ebs-csi-driver pods are not running"
              exit 1
            fi


      - name: Install S3 CSI Driver
        run: |
          helm repo add aws-mountpoint-s3-csi-driver https://awslabs.github.io/mountpoint-s3-csi-driver
          helm repo update
          helm upgrade --install aws-mountpoint-s3-csi-driver \
            --namespace kube-system \
            aws-mountpoint-s3-csi-driver/aws-mountpoint-s3-csi-driver

            kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=aws-mountpoint-s3-csi-driver -n kube-system --timeout=120s
            if [ $? -eq 0 ]; then
              echo "aws-mountpoint-s3-csi-driver pods are running"
            else
              echo "aws-mountpoint-s3-csi-driver pods are not running"
              exit 1
            fi

      - name: Attach role to S3 CSI service account
        run: kubectl apply -f ./manifests/s3/s3-csi-driver-sa.yaml

      - name: Create storage for S3
        run: |
          kubectl apply -f ./manifests/s3/pv-pvc-init.yaml -n dev
          
          # if ! kubectl get pv pv-s3 >/dev/null 2>&1; then
          #   kubectl apply -f ./manifests/s3/pv.yaml
          # else
          #   echo "PV already exists"
          # fi

          # if ! kubectl get pvc pvc-s3 >/dev/null 2>&1; then
          #   kubectl apply -f ./manifests/s3/pvc.yaml -n dev
          # else
          #   echo "PVC already exists"
          # fi

      - name: Deploy Helm Chart to Dev
        run: |
          helm upgrade --install dev-ds-translator ./helm/ds-translator \
            --namespace dev \
            --create-namespace \
            --values ./helm/ds-translator/values-dev.yaml \
      # --set image.tag=${{ env.IMAGE_TAG }}

      - name: Create or Update API Key Secret in Dev
        run: |
          kubectl create secret generic openai-api-key \
            --from-literal=OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }} \
            --namespace dev --dry-run=client -o yaml | kubectl apply -f -

          kubectl create secret generic deepl-api-key \
          --from-literal=DEEPL_API_KEY=${{ secrets.DEEPL_API_KEY }} \
          --namespace dev --dry-run=client -o yaml | kubectl apply -f -

      - name: Setting new DNS for domain
        id: get-hostname
        run: |
          echo ">> Waiting for public DNS endpoint"
          RETRIES=20
          attempt=1

          while [ $attempt -le $RETRIES ]; do
            HOSTNAME=$(kubectl get ingress dev-ds-translator-ds-translator-ingress -n dev -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            if [ -n "$HOSTNAME" ]; then
              echo "Ingress hostname found: ${HOSTNAME}"
              break
            fi
            echo "Attempt ${attempt}: Hostname is empty. Waiting for 5 seconds..."
            sleep 5
            attempt=$((attempt + 1))
          done

          if [ -z "$HOSTNAME" ]; then
            echo "The cluster has no public DNS endpoint (retries: ${RETRIES})."
            exit 1
          fi

          # Set the output for subsequent steps
          echo "::set-output name=hostname::${HOSTNAME}"

      - name: Apply DNS Changes
        run: |
          # Replace placeholders in the template with the actual values.
          sed -e "s/__ENVIRONMENT__/dev\./g" \
              -e "s/__TARGET__/${{ steps.get-hostname.outputs.hostname }}/g" \
              dns/change-batch.json > change-batch-temp.json
          cat change-batch-temp.json 

          echo "Applying DNS changes..."
          CHANGE_ID=$(aws route53 change-resource-record-sets \
            --hosted-zone-id ${{ secrets.AWS_HOSTED_ZONE_ID }} \
            --change-batch file://change-batch-temp.json \
            --query 'ChangeInfo.Id' --output text)
          echo "Change submitted. Change ID: ${CHANGE_ID}"

          # Poll for status until it becomes INSYNC.
          echo "Waiting for DNS change to be INSYNC..."
          until [ "$(aws route53 get-change --id ${CHANGE_ID} --query 'ChangeInfo.Status' --output text)" == "INSYNC" ]; do
            echo "DNS change is still pending. Sleeping for 10 seconds..."
            sleep 10
          done

          echo "DNS change is INSYNC."

      - name: Run Integration Tests on Dev
        run: |
          echo ">> Running basic connection test"
          RETRIES=18
          COUNT=0
          until curl --fail https://dev.dstranslator.cloud; do
            COUNT=$((COUNT+1))
            if [ $COUNT -ge $RETRIES ]; then
              echo "DNS not propagated after $RETRIES attempts."
              exit 1
            fi
            echo "Domain not reachable yet. Retrying in 10 seconds... ($COUNT/$RETRIES)"
            sleep 10
          done
          echo "Domain and website can be reached"

  package-artifact:
    if: github.ref == 'refs/heads/release'  
    name: Package Helm Chart Artifact
    # needs: deploy-dev
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetch all history and tags

      - name: Set up Helm
        uses: azure/setup-helm@v4.3.0

      - name: Package Helm Chart
        run: |
          TAG=$(git describe --tags --abbrev=0)
          # helm package ./helm/ds-translator --version ${TAG}+${GITHUB_SHA} --destination packaged-charts
          helm package ./helm/ds-translator 

      - name: Upload Helm Chart Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ds-translator-chart
          path: ds-translator-*.tgz

      - name: Display structure of downloaded files
        run: ls -R

  promote-to-stage:
    if: github.ref == 'refs/heads/release'  
    name: Promote to Stage
    needs: package-artifact
    runs-on: ubuntu-latest

    # environment: stage  # Requires manual approval via GitHub environment protection
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials for Stage
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ SECRETS.AWS_ACCOUNT_ID }}:role/dst-stage-github-deployment-role
          aws-region: ${{ SECRETS.AWS_REGION }}

      - name: Update kubeconfig for Stage
        run: aws eks update-kubeconfig --region ${{ SECRETS.AWS_REGION }} --name dst-stage-cluster

      - name: Set up Helm
        uses: azure/setup-helm@v4.3.0

      - name: Download Helm Chart Artifact
        uses: actions/download-artifact@v4
        with:
          name: ds-translator-chart

      - name: Display structure of downloaded files
        run: ls -R

      # installed with terraform as module
      # - name: Install AWS Observability in Stage
      #   run: |      
      #     helm repo add aws-observability https://aws-observability.github.io/helm-charts
      #     helm repo update aws-observability
      #     helm install --wait --create-namespace \
      #       --namespace amazon-cloudwatch \ 
      #       amazon-cloudwatch aws-observability/amazon-cloudwatch-observability \ 
      #       --set clusterName=dst-stage-cluster \
      #       --set region=${{ SECRETS.AWS_REGION }}

      - name: Install S3 CSI Driver
        run: |
          helm repo add aws-mountpoint-s3-csi-driver https://awslabs.github.io/mountpoint-s3-csi-driver
          helm repo update
          helm upgrade --install aws-mountpoint-s3-csi-driver \
            --namespace kube-system \
            aws-mountpoint-s3-csi-driver/aws-mountpoint-s3-csi-driver

            kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=aws-mountpoint-s3-csi-driver -n kube-system --timeout=120s
            if [ $? -eq 0 ]; then
              echo "aws-mountpoint-s3-csi-driver pods are running"
            else
              echo "aws-mountpoint-s3-csi-driver pods are not running"
              exit 1
            fi

      - name: Attach role to S3 CSI service account
        run: kubectl apply -f ./manifests/s3/s3-csi-driver-sa.yaml

      - name: Create storage for S3
        run: |
          kubectl apply -f ./manifests/s3/pv-pvc-init.yaml -n stage
          
          # if ! kubectl get pv pv-s3 >/dev/null 2>&1; then
          #   kubectl apply -f ./manifests/s3/pv.yaml
          # else
          #   echo "PV already exists"
          # fi

          # if ! kubectl get pvc pvc-s3 >/dev/null 2>&1; then
          #   kubectl apply -f ./manifests/s3/pvc.yaml -n dev
          # else
          #   echo "PVC already exists"
          # fi


      - name: Deploy Helm Chart to Stage
        run: |
          helm upgrade --install stage-ds-translator ds-translator-*.tgz \
            --namespace stage \
            --create-namespace \
            --values helm/ds-translator/values-stage.yaml
      # --set image.tag=${{ env.IMAGE_TAG }}

      - name: Create or Update API Key Secret in Stage
        run: |
          kubectl create secret generic openai-api-key \
            --from-literal=OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }} \
            --namespace stage --dry-run=client -o yaml | kubectl apply -f -

          kubectl create secret generic deepl-api-key \
          --from-literal=DEEPL_API_KEY=${{ secrets.DEEPL_API_KEY }} \
          --namespace stage --dry-run=client -o yaml | kubectl apply -f -

      - name: Setting new DNS for domain
        id: get-hostname
        run: |
          echo ">> Waiting for public DNS endpoint"
          RETRIES=10
          attempt=1

          while [ $attempt -le $RETRIES ]; do
            HOSTNAME=$(kubectl get ingress stage-ds-translator-ds-translator-ingress -n stage -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            if [ -n "$HOSTNAME" ]; then
              echo "Ingress hostname found: ${HOSTNAME}"
              break
            fi
            echo "Attempt ${attempt}: Hostname is empty. Waiting for 5 seconds..."
            sleep 5
            attempt=$((attempt + 1))
          done

          if [ -z "$HOSTNAME" ]; then
            echo "The cluster has no public DNS endpoint (retries: ${RETRIES})."
            exit 1
          fi

          # Set the output for subsequent steps
          echo "::set-output name=hostname::${HOSTNAME}"

      - name: Apply DNS Changes
        run: |
          # Replace placeholders in the template with the actual values.
          sed -e "s/__ENVIRONMENT__/stage\./g" \
              -e "s/__TARGET__/${{ steps.get-hostname.outputs.hostname }}/g" \
              dns/change-batch.json > change-batch-temp.json
          cat change-batch-temp.json 

          echo "Applying DNS changes..."
          CHANGE_ID=$(aws route53 change-resource-record-sets \
            --hosted-zone-id ${{ secrets.AWS_HOSTED_ZONE_ID }} \
            --change-batch file://change-batch-temp.json \
            --query 'ChangeInfo.Id' --output text)
          echo "Change submitted. Change ID: ${CHANGE_ID}"

          # Poll for status until it becomes INSYNC.
          echo "Waiting for DNS change to be INSYNC..."
          until [ "$(aws route53 get-change --id ${CHANGE_ID} --query 'ChangeInfo.Status' --output text)" == "INSYNC" ]; do
            echo "DNS change is still pending. Sleeping for 10 seconds..."
            sleep 10
          done

          echo "DNS change is INSYNC."

      - name: Run Integration Tests on Stage
        run: |
          echo ">> Running basic connection test"
          RETRIES=18
          COUNT=0
          until curl --fail https://stage.dstranslator.cloud; do
            COUNT=$((COUNT+1))
            if [ $COUNT -ge $RETRIES ]; then
              echo "DNS not propagated after $RETRIES attempts."
              exit 1
            fi
            echo "Domain not reachable yet. Retrying in 10 seconds... ($COUNT/$RETRIES)"
            sleep 10
          done
          echo "Domain and website can be reached"

  promote-to-prod:
    if: github.ref == 'refs/heads/release'
    name: Promote to Production
    needs: promote-to-stage
    runs-on: ubuntu-latest

    # environment: prod  # Requires manual approval via GitHub environment protection

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials for Production
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ SECRETS.AWS_ACCOUNT_ID }}:role/dst-prod-github-deployment-role
          aws-region: ${{ SECRETS.AWS_REGION }}

      - name: Update kubeconfig for Production
        run: aws eks update-kubeconfig --region ${{ SECRETS.AWS_REGION }} --name dst-prod-cluster

      - name: Set up Helm
        uses: azure/setup-helm@v4.3.0

      - name: Download Helm Chart Artifact
        uses: actions/download-artifact@v4
        with:
          name: ds-translator-chart

      - name: Display structure of downloaded files
        run: ls -R

      #  installed in terraform with module
      # - name: Install AWS Observability in Production
      #   run: |      
      #     helm repo add aws-observability https://aws-observability.github.io/helm-charts
      #     helm repo update aws-observability
      #     helm install --wait --create-namespace \
      #       --namespace amazon-cloudwatch \ 
      #       amazon-cloudwatch aws-observability/amazon-cloudwatch-observability \ 
      #       --set clusterName=dst-production-cluster \
      #       --set region=${{ SECRETS.AWS_REGION }}

      - name: Install S3 CSI Driver
        run: |
          helm repo add aws-mountpoint-s3-csi-driver https://awslabs.github.io/mountpoint-s3-csi-driver
          helm repo update
          helm upgrade --install aws-mountpoint-s3-csi-driver \
            --namespace kube-system \
            aws-mountpoint-s3-csi-driver/aws-mountpoint-s3-csi-driver

            kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=aws-mountpoint-s3-csi-driver -n kube-system --timeout=120s
            if [ $? -eq 0 ]; then
              echo "aws-mountpoint-s3-csi-driver pods are running"
            else
              echo "aws-mountpoint-s3-csi-driver pods are not running"
              exit 1
            fi

      - name: Attach role to S3 CSI service account
        run: kubectl apply -f ./manifests/s3/s3-csi-driver-sa.yaml

      - name: Create storage for S3
        run: |
          kubectl apply -f ./manifests/s3/pv-pvc-init.yaml -n prod
          
          # if ! kubectl get pv pv-s3 >/dev/null 2>&1; then
          #   kubectl apply -f ./manifests/s3/pv.yaml
          # else
          #   echo "PV already exists"
          # fi

          # if ! kubectl get pvc pvc-s3 >/dev/null 2>&1; then
          #   kubectl apply -f ./manifests/s3/pvc.yaml -n dev
          # else
          #   echo "PVC already exists"
          # fi



      - name: Deploy Helm Chart to Production
        run: |
          helm upgrade --install prod-ds-translator ds-translator-*.tgz \
            --namespace prod \
            --create-namespace \
            --values helm/ds-translator/values-prod.yaml
      # --set image.tag=${{ env.IMAGE_TAG }}

      - name: Create or Update API Key Secret in Production
        run: |
          kubectl create secret generic openai-api-key \
            --from-literal=OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }} \
            --namespace prod --dry-run=client -o yaml | kubectl apply -f -

          kubectl create secret generic deepl-api-key \
          --from-literal=DEEPL_API_KEY=${{ secrets.DEEPL_API_KEY }} \
          --namespace prod --dry-run=client -o yaml | kubectl apply -f -

      - name: Setting new DNS for domain
        id: get-hostname
        run: |
          echo ">> Waiting for public DNS endpoint"
          RETRIES=20
          attempt=1

          while [ $attempt -le $RETRIES ]; do
            HOSTNAME=$(kubectl get ingress prod-ds-translator-ds-translator-ingress -n prod -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            if [ -n "$HOSTNAME" ]; then
              echo "Ingress hostname found: ${HOSTNAME}"
              break
            fi
            echo "Attempt ${attempt}: Hostname is empty. Waiting for 5 seconds..."
            sleep 5
            attempt=$((attempt + 1))
          done

          if [ -z "$HOSTNAME" ]; then
            echo "The cluster has no public DNS endpoint (retries: ${RETRIES})."
            exit 1
          fi

          # Set the output for subsequent steps
          echo "::set-output name=hostname::${HOSTNAME}"

      - name: Apply DNS Changes
        run: |
          # Replace placeholders in the template with the actual values.
          sed -e "s/__ENVIRONMENT__/www\./g" \
              -e "s/__TARGET__/${{ steps.get-hostname.outputs.hostname }}/g" \
              dns/change-batch.json > change-batch-temp.json
          cat change-batch-temp.json 

          echo "Applying DNS changes..."
          CHANGE_ID=$(aws route53 change-resource-record-sets \
            --hosted-zone-id ${{ secrets.AWS_HOSTED_ZONE_ID }} \
            --change-batch file://change-batch-temp.json \
            --query 'ChangeInfo.Id' --output text)
          echo "Change submitted. Change ID: ${CHANGE_ID}"

          # Poll for status until it becomes INSYNC.
          echo "Waiting for DNS change to be INSYNC..."
          until [ "$(aws route53 get-change --id ${CHANGE_ID} --query 'ChangeInfo.Status' --output text)" == "INSYNC" ]; do
            echo "DNS change is still pending. Sleeping for 10 seconds..."
            sleep 10
          done

          echo "DNS change is INSYNC."

      - name: Run Integration Tests on Production
        run: |
          echo ">> Running basic connection test"
          RETRIES=18
          COUNT=0
          until curl --fail https://www.dstranslator.cloud; do
            COUNT=$((COUNT+1))
            if [ $COUNT -ge $RETRIES ]; then
              echo "DNS not propagated after $RETRIES attempts."
              exit 1
            fi
            echo "Domain not reachable yet. Retrying in 10 seconds... ($COUNT/$RETRIES)"
            sleep 10
          done
          echo "Domain and website can be reached"
